---
title: "Using ggvis with knitr and rmarkdown"
output:
  html_document:
    fig_width: 4
    fig_height: 2
runtime: shiny
---

```{r echo=FALSE}
# Set up default dimensions. Width and height are multiplied by dpi to get
# pixel dimensions.
knitr::opts_chunk$set(fig.width = 4, fig.height = 3)
```

To embed a ggvis plot just call `ggvis`:

```{r, message = FALSE}
library(ggvis)
mtcars %>% ggvis(x = ~wt, y = ~mpg) %>% layer_points()
```


```{r, fig.width = 8, fig.height = 6}
mtcars %>% ggvis(x = ~wt, y = ~mpg) %>%
  layer_points() %>%
  layer_smooths()
```


```{r echo=FALSE, message = FALSE}
library(knitr)
library(ggvis)
library(shiny)
library(dplyr)
```

An interactive plot:

```{r, message = FALSE, fig.width = 6, fig.height = 4}
cocaine %>%
  ggvis(x = ~potency) %>%
  layer_histograms(width = input_slider(1, 20, value = 5))
```

```{r, message = FALSE, echo = FALSE}
library(ggvis)
library(shiny)
set.seed(1233)
cocaine <- cocaine[sample(1:nrow(cocaine), 500), ]
```

Two linked plots. Brushing in the scatter plot will update the histogram.

```{r fig.width = 4, fig.height = 3, echo = FALSE, results = "hold"}
cocaine$id <- seq_len(nrow(cocaine))
lb <- linked_brush(keys = cocaine$id, "red")
cocaine %>%
  ggvis(~weight, ~price, key := ~id) %>%
  layer_points(fill := lb$fill, fill.brush := "red", opacity := 0.3) %>%
  lb$input()
# A subset of cocaine, of only the selected points
selected <- lb$selected
cocaine_selected <- reactive({
  cocaine[selected(), ]
})
cocaine %>%
  ggvis(~potency) %>%
  layer_histograms(width = 5, boundary = 0) %>%
  add_data(cocaine_selected) %>%
  layer_histograms(width = 5, boundary = 0, fill := "#dd3333")
```

A summary of the selected points:

```{r, echo = FALSE}
renderPrint(
  summary(cocaine_selected())
)
```

```{r}
# Add ID column to mtcars so that we can select from it
mtcars2 <- cbind(mtcars, id = seq_len(nrow(mtcars)))
lb <- linked_brush(keys = mtcars2$id, "red")
```

Next we create two plots. Points that are brushed on the first plot will be displayed on the second plot, and the scales will automatically adjust so that those points fill the plot.

```{r fig.width = 3, fig.height = 3, results = "hold"}
mtcars2 %>%
  ggvis(~disp, ~mpg, key := ~id) %>%
  layer_points(fill := lb$fill, fill.brush := "red") 
  
# A subset of mtcars2, of only the selected points, or the whole data if nothing
# is selected.
selected <- lb$selected
mtcars2_selected <- reactive({
  if (!any(selected())) return(mtcars2)
  mtcars2[selected(), ]
})
mtcars2_selected %>%
  ggvis(~disp, ~mpg) %>%
  layer_points(key := ~id) %>%
  set_options(duration = 100)
```

Also, we can show a table of the data, including a column indicating which ones are selected:

```{r}
renderTable(
  cbind(mtcars2, selected = selected())
)
```